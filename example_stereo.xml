<xml>
<repository>
	<!-- list available binaries and
		  * (optional) what component they implement (defaults to binary name)
		  * (optional) what version they implement (defaults to 0)
	//-->
	<binary name="stereo_match" />
	<binary name="camera" />
	<binary name="debay">
		<component name="debay_left" />
		<component name="debay_right" />
	</binary>
	<binary name="rect">
		<component name="rect_left" />
		<component name="rect_right" />
	</binary>
	<binary name="disp_to_pc" />
	<binary name="object_recog" />
	<binary name="nic_drv" />
	<binary name="nic_bridge" />
	<binary name="remote_rom_client" />
	<binary name="remote_rom_server" />

	<!-- (global) component repository
		    * Contains the model description of all known components.
			 * A component is an atomic software/hardware entity that needs to be instantiated during system configuration.
			 * A component may be implementation-specific and/or platform-specific.
		    * Most of this could be auto-generated from the build system in the future.

		  A component is either an atomic component (<component>) or a composite component (<composite>).
		  The latter is composed of multiple atomic components with predefined interconnections.

		  The model of a component is specified by its requirements and provisions of the following types:
			 * service: Specifies the service interface, i.e. the communication on the IPC/RPC level.
			 * spec: Describes a platform requirement.
			 * rte: Specifies the required/provided run-time environment.

		  A function is thus a means to model dependencies between components (or even functions) in a more generic way.
		  The end user does typically not (want to) care about, e.g., what component implements the network driver or how
		  the GUI subsystem looks like. Depending on the platform, certain services (e.g. Framebuffer, Input, Nic) may be
		  provided by a single component or multiple components. Moreover, the data provided by a ROM service is not part
		  of the session interface.

		  In order to guide the automated configuration, we further distinguish between functional components and library
		  components, i.e. a component either provides/requires a function or is a very generic component that can be
		  auto-inserted, e.g., to convert between service interfaces. Note that a function dependency is transitively
		  satisfied so that library components can be arbitrarily inserted without breaking a function dependency.
		  Currently, we envision the following types of library components:
			 * mux:      A multiplexer which transforms a provided service interface with max_clients=1 to max_clients>1.
			 * protocol: A protocol stack that converts between different service interfaces without changing the data.
			 * proxy:    A proxy that transfers the data exchanged in service interface X over another carrier (e.g.
							 service interface Y) and vice versa.
			 * filter:   A filter that represents arbitrary data processing that typically does not change the service
			             interface (complementary to the protocol stack).
			 * function: (Unambiguously) identifies a particular (but platform- and implementation-independent functionaliy.

		  By default, a component is unclassified. 
	//-->

	<component name="stereo_match">
		<!-- unclassified component (later classified in the scope of a composite component) //-->

		<provides>
			<!-- list provided services //-->
			<service name="ROM" />
		</provides>
		<requires>
			<!-- if the same service interface is required twice, we must distinguish it by the session label //-->
			<service name="ROM" label="left" />
			<service name="ROM" label="right" />

			<!-- list required run-time environment (e.g. native, noux, virtualbox) //-->
			<rte name="native" /> <!-- default //-->
		</requires>
	</component>

	<!-- Camera driver must be a singleton (at most one instance) as it needs exclusive access to the hardware. //-->
	<component name="camera" singleton="true">
		<!-- This component is classified as a function provider. //-->
		<function name="CAMERA" />

		<provides>
			<!-- The camera driver provides a left and a right image to the clients (depending on the session label?). //-->
			<service name="ROM" />
		</provides>
		<requires>
			<!-- list specs (i.e. platform compatibility) //-->
			<spec name="zynq" />
		</requires>
	</component>

	<component name="debay_left">
		<!-- This is a filter component. Filters can be modelled by tags that are added/removed/replaced. //-->
		<filter>
			<!-- Add the `debay` tag to indicate that the provided image has been debayered. //-->
			<add tag="debay" />
			<!-- Remove the `right` tag since this component extracts only the left image from the camera. //-->
			<remove tag="right" />
		</filter>

		<provides>
			<service name="ROM" />
		</provides>
		<requires>
			<!-- service requirements can be constrained by the presence/absence of filter tags (e.g. 'left !debay') //-->
			<service name="ROM" filter="left !debay" />
		</requires>

		<!-- specify default configuration //-->
		<defaults>
			<config rom="left" />
		</defaults>
	</component>

	<!-- similar to `debay_left` (see above) //-->
	<component name="rect_left">
		<filter>
			<add tag="rect" />
			<remove tag="right" />
		</filter>

		<provides>
			<service name="ROM" />
		</provides>
		<requires>
			<service name="ROM" filter="left !rect" />
		</requires>

		<defaults>
			<config rom="left" />
		</defaults>
	</component>

	<!-- similar to `debay_left` (see above) //-->
	<component name="debay_right">
		<filter>
			<add tag="debay" />
			<remove tag="left" />
		</filter>

		<provides>
			<service name="ROM" />
		</provides>
		<requires>
			<service name="ROM" filter="right !debay" />
		</requires>

		<defaults>
			<config rom="right" />
		</defaults>
	</component>

	<!-- similar to `debay_left` (see above) //-->
	<component name="rect_right">
		<filter>
			<add tag="rect" />
			<remove tag="left" />
		</filter>

		<provides>
			<service name="ROM" />
		</provides>
		<requires>
			<service name="ROM" filter="right !rect" />
		</requires>

		<defaults>
			<config rom="right" />
		</defaults>
	</component>
	
	<component name="disp_to_pc">
		<filter>
			<!-- remove all tags and replace with new ones //-->
			<reset tag="pointcloud" />
		</filter>

		<provides>
			<service name="ROM" />
		</provides>
		<requires>
			<service name="ROM" label="disp" />
			<service name="ROM" label="camera" />
		</requires>
	</component>

	<component name="nic_drv" singleton="true">
		<function name="Network" />
		<provides>
			<service name="Nic" max_clients="1" />
		</provides>
	</component>

	<component name="nic_bridge">
        <mux service="Nic" />

		<provides>
			<service name="Nic" /> <!-- max_clients defaults to an unlimited number //-->
		</provides>
		<requires>
			<service name="Nic" />
		</requires>
	</component>

	<component name="remote_rom_client">
		<!-- unclassified component (later classified in the scope of a composite component) //-->
		<provides>
			<service name="ROM" />
		</provides>

		<requires>
			<service name="Nic" />
		</requires>
	</component>

	<component name="remote_rom_server">
		<!-- unclassified component (later classified in the scope of a composite component) //-->
		<requires>
			<service name="Nic" />
			<service name="ROM" />
		</requires>
	</component>

    <component name="object_recog">
        <requires>
            <service name="ROM" filter="pointcloud" />
        </requires>
    </component>

	<composite name="ROM_PROXY">
		<!-- A proxy is a special type of auto-instantiable (composite) component that encapsulates a service/function (e.g.
			  ROM) over within another service (e.g. Nic).
			  Typically, a proxy is a composite consisting of one component converting between the original service to the
			  carrier service and another component converting between the carrier service and the original service. In
			  contrast to a protocol stack, a proxy may use the same carrier (e.g. network, filesystem) for multiple
			  communication channels so that there is some filtering/policy agreement involved. //-->
		<proxy carrier="Nic" />

		<!-- remark: A composite only specifies the "external" (i.e. functionally relevant) requirements/provisions.
			          Internal requirements are taken from the component specifications. //-->
		<provides>
			<service name="ROM" />
		</provides>
		<requires>
			<service name="ROM" />
			<service name="Nic" function="Network" />
		</requires>

		<pattern>
			<!-- TODO requires auto-generated policy //-->
            <component name="remote_rom_client">
                <expose>
                    <service name="ROM" />
                </expose>
            </component>
            <component name="remote_rom_server">
                <route>
						 <service name="ROM"><external /></service>
                         <service name="Nic"><external /></service>
                </route>
            </component>
		</pattern>
	</composite>

	<composite>
		<!-- This component is classified as a function provider. //-->
		<function name="STEREO_MATCH" />

		<!-- Provisions and requirements could (in principle) be derived from the patterns. However, it is supposedly a
			  good idea to specify at this level to what specification all pattern must adhere. //-->
		<provides>
			<service name="ROM" />
		</provides>
		<requires>
			<service name="ROM" function="CAMERA" />
		</requires>

		<pattern>
			<component name="debay_left">
				<!-- route ROM requirement to ROM service provided by `CAMERA` function //-->
				<route><service name="ROM"><external/></service></route>
			</component>
			<component name="debay_right">
				<!-- route ROM requirement to ROM service provided by `CAMERA` function //-->
				<route><service name="ROM"><external/></service></route>
			</component>
			<component name="rect_left">
				<!-- route ROM requirement internally //-->
				<route><service name="ROM"><child name="debay_left" /></service></route>
			</component>
			<component name="rect_right">
				<!-- route ROM requirement internally //-->
				<route><service name="ROM"><child name="debay_right" /></service></route>
			</component>
			<component name="stereo_match">
				<route>
					<!-- route ROM requirements internally //-->
					<service name="ROM" label="left"><child name="rect_left" /></service>
					<service name="ROM" label="right"><child name="rect_right" /></service>
				</route>
				<expose>
					<!-- expose provided ROM service (link to composite provision) //-->
					<service name="ROM" />
				</expose>
			</component>
		</pattern>

		<pattern>
			<component name="rect_left">
				<route><service name="ROM"><external /></service></route>
			</component>
			<component name="rect_right">
				<route><service name="ROM"><external /></service></route>
			</component>
			<component name="stereo_match">
				<route>
					<service name="ROM" label="left"><child name="rect_left" /></service>
					<service name="ROM" label="right"><child name="rect_right" /></service>
				</route>
				<expose>
					<service name="ROM" />
				</expose>
			</component>
		</pattern>
	</composite>

	<composite>
		<function name="DISP_TO_PC" />
		<provides>
			<service name="ROM" />
		</provides>
		<requires>
			<service name="ROM" label="cam" function="CAMERA" />
			<service name="ROM" label="match" function="STEREO_MATCH" />
		</requires>

		<pattern>
			<component name="debay_left">
				<route><service name="ROM"><external function="CAMERA"/></service></route>
			</component>

			<component name="rect_left">
				<route><service name="ROM"><child name="debay_left" /></service></route>
			</component>

			<component name="disp_to_pc">
				<route>
					<service name="ROM" label="camera"><child name="rect_left" /></service>
					<service name="ROM" label="disp"><external function="STEREO_MATCH"/></service>
				</route>
				<expose>
					<service name="ROM" />
				</expose>
				<!-- set config / override default config //-->
				<config>
					<left />
				</config>
			</component>
		</pattern>

		<pattern>
			<component name="debay_right">
				<route><service name="ROM"><external function="CAMERA"/></service></route>
			</component>

			<component name="rect_right">
				<route><service name="ROM"><child name="debay_right" /></service></route>
			</component>

			<component name="disp_to_pc">
				<route>
					<service name="ROM" label="camera"><child name="rect_right" /></service>
					<service name="ROM" label="disp"><external function="STEREO_MATCH"/></service>
				</route>
				<expose>
					<service name="ROM" />
				</expose>
				<config>
					<right />
				</config>
			</component>
		</pattern>
	</composite>
</repository>

<!-- example abstract config //-->
<system name="stereo"> 
    <provides>
        <spec name="zynq" />
    </provides>


	<!-- first level are (unconnected) subsystems //-->
	<subsystem name="zynq">

		<!-- explicitly ask for CAMERA function //-->
        <child name="CAM"><function name="CAMERA" /></child>
		
		<!-- requires unambiguous function CAMERA //-->
        <child name="STEREO">
            <function name="STEREO_MATCH" />
            <dependency>
                <child name="CAM" />
            </dependency>
        </child>

		<!-- requires unambiguous functions CAMERA and STEREO_MATCH //-->
        <child name="PC">
            <function name="DISP_TO_PC" />
            <dependency>
                <child name="CAM" />
                <child name="STEREO" />
            </dependency>
        </child>

		<!-- remark: ROM proxies are automatically instantiated //-->
        <child name="NIC"><function name="Network" /></child>

	</subsystem>

	<subsystem name="pc">

		<!-- explicitly connect ROM service to DISP_TO_PC //-->
        <child>
            <component name="object_recog" />
            <!-- TODO can we also deal with just a dependency to pc-provider? //-->
			<route>
				<service name="ROM"><child name="PC" /></service>
			</route>
		</child>

		<!-- remark: ROM proxies are automatically instantiated //-->
        <child name="NIC"><function name="Network" /></child>

	</subsystem>
</system>

</xml>
